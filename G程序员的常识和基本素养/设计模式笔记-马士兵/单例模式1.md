# 第一步



# 第二步

使用final，缺点是无法修改配置文件。



# 第三步

```java
public class Singleton2 {
	private static Singleton2 instance;
	
	private static Object lock = new Object();
	
	private Singleton2() {}
	
	public static Singleton2 getInstance() {
		try {
			Thread.sleep(10); // 睡这一毫秒区别很大!!可以模拟阻塞的场景,否则就是接近于顺序执行的方式了
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		if(instance == null) {
			synchronized(lock) {
				if(instance == null) { // 这里为啥还要判断一次?防止重复new
					instance = new Singleton2();
				}				
			}

//			instance = new Singleton2();
		}
		return instance;
	}
}	
```





# 第四步 静态内部类

![image-20200402082258971](/Users/zxzx/projects/programmer_blogs/G程序员的常识和基本素养/设计模式笔记-马士兵/模板.assets/image-20200402082258971.png)





# 总结

