### 滑动窗口 leet239
https://leetcode.com/problems/sliding-window-maximum/submissions/
```python
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        if nums == []: return [] 
        res = []
        pos = 0
        for i in range(0,k):
            if nums[i] >= nums[pos]:
                pos = i                
        res.append(nums[pos])    
        for i in range(1, len(nums)-k+1):
            if i <= pos:
                if nums[i+k-1] <= nums[pos]:
                    res.append(nums[pos])                    
                else:
                    res.append(nums[i+k-1])
                    pos = i+k-1
            if i > pos:
                pos = i
                for j in range(i, i+k):
                    if nums[j] > nums[pos]:
                        pos = j  
                res.append(nums[pos])
        return res
```

### list 链表 python 

```python
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

    # def __repr__(self):
    #     # return self.val + 'next is ' + self.next.val if self.next else 'None'
    #     return self.val
    #
    def __str__(self):
        return self.val
'''列表转链表'''
def make_linkedlist(list1):
    a = b = ListNode(0)
    for i in list1:
        b.next = ListNode(i)
        b = b.next
    return a.next

def print_linkedlist(listNode):
    if listNode is None:
        print('linkedlist is None')
    while listNode:
        print(listNode.val, end=",")
        listNode = listNode.next


ls = [1, 2, 3, 4, 5, 6]
lkls = make_linkedlist(ls)
print_linkedlist(lkls)


print('')

'''原地反转，非头插法'''
def reverse(head):
    if head is None:
        return None
    pre = None
    cur = head
    next = cur.next
    while next is not None:
        cur.next = pre
        pre = cur
        cur = next
        next = next.next
    cur.next = pre
    return cur
```



### leet234 回文链表的判断

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        # 获取长度
        tmp = head
        length = 0
        while tmp:
            length += 1
            tmp = tmp.next        
        # 获取中间点
        tmp = head
        half = (length+1)//2
        while half > 0:
            tmp = tmp.next
            half -= 1            
        # 反转链表
        tmp = self.reverse_linkedlist(tmp)
        # 逐一对照
        while tmp:
            if tmp.val != head.val:
                return False
            tmp = tmp.next
            head = head.next
        return True
       
    def reverse_linkedlist(self, head: ListNode)->ListNode:
        if head is None: return head
        dummy = ListNode(0)
        while head:
            tmp = head
            head = head.next
            tmp.next = dummy.next
            dummy.next = tmp            
        return dummy.next            
```

### 基于数组的回文的数量统计

```python
class Solution:
    def countSubstrings(self, s: str) -> int:
        cnt = 0
        for i in range(len(s)):
            cnt += self.check(s, i, i)  # 奇数
            cnt += self.check(s, i, i + 1)  # 偶数
        return cnt
		
    def check(self, s, i, j):
      """
      统计回文的数量
      """
        cnt = 0
        length = len(s)
        while i > -1 and j < length and s[i] == s[j]:
            cnt += 1
            i -= 1
            j += 1
        return cnt
```





### 链表的排序

```python
class Solution:
    def sortList(self, head: ListNode) -> ListNode:
        # 分治法解决
        if head is None or head.next is None: return head
        # 链表切割成两半
        slow = slow_pre = fast = head
        while fast and fast.next:
            slow_pre = slow
            slow = slow.next
            fast = fast.next.next
        slow_pre.next = None        
        # 两半分别进行归并排序
        return self.merge(self.sortList(head), self.sortList(slow))        
    
    def merge(self, list1, list2):
        dummy = rear = ListNode(0)
        while list1 and list2:
            if list1.val <= list2.val:
                rear.next = list1
                list1 = list1.next
            else:
                rear.next = list2
                list2 = list2.next
            rear = rear.next 
        if list1: rear.next = list1 
        if list2: rear.next = list2  
        return dummy.next
```



### LRUCache

```python
class LRUCache:
    
    class Node:
        def __init__(self, k, v):
            self.v = v # value
            self.next = None
            self.pre = None 
            self.k = k # key            

    def __init__(self, capacity: int):
        # 维护一个双链表
        # 设计双链表结点的结构
        # 结点结构又能放入哈希表里面去
        # 检查
        self.capacity = capacity
        self.size = 0
        self.dummy = self.Node(-1,0)         
        self.tail = self.Node(-1,0)     
        self.dummy.next = self.tail 
        self.tail.pre = self.dummy

    def get(self, key: int) -> int:
        nxt = self.dummy
        res_node = None
        # 遍历寻找
        while nxt and nxt is not self.tail:
            if nxt.k == key:
                res_node = nxt
                break
            nxt = nxt.next
        # 为空
        if res_node is None: return -1
        # 找到
        self.move_node(res_node) # 调整到第一个位置
        return res_node.v
    
    def put(self, key: int, value: int) -> None:
        # 先查找
        nxt = self.dummy.next
        res_node = None
        # 遍历寻找
        while nxt and nxt is not self.tail:
            if nxt.k == key:
                res_node = nxt
                break
            nxt = nxt.next
        # 找到更新并移位
        if res_node is not None:
            res_node.v = value
            self.move_node(res_node)
        # 没有找到
        # 没有找到则新建并放到头部         
        else:
            # 没有位置则删除最后一个   
            if self.size >= self.capacity:
                self.tail.pre.pre.next =self.tail
                self.tail.pre = self.tail.pre.pre   
                self.size -= 1           
            res_node = self.Node(key, value)
            self.insert_node(res_node)
            self.size += 1
    
    def insert_node(self, node):
        node.next = self.dummy.next
        node.pre = self.dummy
        self.dummy.next.pre = node
        self.dummy.next = node

    def move_node(self, node):
        if  node is self.dummy.next :
            return
        else:
            node.next.pre = node.pre
            node.pre.next = node.next
            # 如果是尾巴结点
        self.insert_node(node)
                        
# Your LRUCache object will be instantiated and called as such:
# obj = LRUCache(capacity)
# param_1 = obj.get(key)
# obj.put(key,value)
```



linked_hashmap

```python
class LRUCache:
    
    class Node:
        def __init__(self, k,v):
            self.k = k # value
            self.v = v # value
            self.next = None
            self.pre = None        

    def __init__(self, capacity: int):
        # 维护一个双链表
        # 设计双链表结点的结构
        # 结点结构又能放入哈希表里面去
        # 检查
        self.capacity = capacity
        self.size = 0
        self.dummy = self.Node(-1, -1)         
        self.tail = self.Node(-1, -1)     
        self.dummy.next = self.tail 
        self.tail.pre = self.dummy
        self.table = {}

    def get(self, key: int) -> int:
        nxt = self.dummy
        res_node = None
        res_node = self.table.get(key)
        # 为空
        if res_node is None: return -1
        # 找到
        self.move_node(res_node) # 调整到第一个位置
        return res_node.v
    
    def put(self, key: int, value: int) -> None:
        # 先查找
        nxt = self.dummy.next
        res_node = None
        # 遍历寻找
        res_node = self.table.get(key)
        # 找到更新并移位
        if res_node is not None:
            self.table[key].v = value
            self.move_node(res_node)
        # 没有找到
        # 没有找到则新建并放到头部         
        else:
            # 没有位置则删除最后一个   
            if self.size >= self.capacity:
                del self.table[self.tail.pre.k] # 不能忘了哈希表要删除    
                self.tail.pre.pre.next =self.tail
                self.tail.pre = self.tail.pre.pre   
                self.size -= 1   
                                              
            res_node = self.Node(key, value)
            self.table[key] = res_node
            self.insert_node(res_node)
            self.size += 1
    
    def insert_node(self, node):
        node.next = self.dummy.next
        node.pre = self.dummy
        self.dummy.next.pre = node
        self.dummy.next = node

    def move_node(self, node):
        if  node is self.dummy.next :
            return
        else:
            node.next.pre = node.pre
            node.pre.next = node.next
            # 如果是尾巴结点
        self.insert_node(node)
                        
# Your LRUCache object will be instantiated and called as such:
# obj = LRUCache(capacity)
# param_1 = obj.get(key)
# obj.put(key,value)
```



### leet42 小顶栈存水问题

```python
class Solution:
    def trap(self, height: List[int]) -> int:
        stack = []
        res = 0
        i = 0
        while i < len(height):
            if len(stack)==0 or height[i] <= height[stack[-1]]:
                stack.append(i)
                i+=1
            else:
                low_index = stack.pop()
                if len(stack)==0: continue
                res += (min(height[i], height[stack[-1]])-height[low_index])*(i-stack[-1]-1) 
        return res
```



### leet55 跳跃游戏

倒数

```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:        
        reach = len(nums) - 1
        for i in range(reach-1, -1, -1):
            if  reach - i > nums[i]  : continue
            else:
                reach = i
        return reach == 0
```



### 失败的算法 leet32

```python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        lc = rc = res = left = 0 # 左右括号的数量都初始化为0
        # 如果当前字符为左括号，左括号的数量 >=右括号，合法
        # 如果是右括号，而且右括号的数量大于左括号，非法，本字符串结束
        while s[0] == ')': s = s[1:]
        while s[-1] == '(': s = s[:-1]
        length = len(s)
        for i in range(length):
            if s[i] == '(':
                lc += 1
            else:
                if rc+1 > lc:
                    res = max(res, i-left)
                    lc = rc = 0
                    left = i+1
                else:
                    rc += 1
        i = left
        while i < length:
            if s[i] == ')':
                left += 1
                rc -= 1
                i += 1
            elif lc > rc and s[i] == '(':
                left += 1
                lc -= 1
                i += 1
            else:
                break
        res = max(res, length-left)
        return res

if __name__ == '__main__':
    # s = ")()(((())))("
    s = "(())()(()((" # 没有考虑特殊情况
    Solution().longestValidParentheses(s)
    这个题不适合使用滑动窗口
```

```python
# 清单1
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        left = 0
        res = 0
        stack = []
        for i in range(len(s)):
            if s[i] == '(':
                stack.append(i)
            elif len(stack) == 0:
                    left = i+1
            else:
                top = stack.pop()
                if len(stack) == 0:
                    res = max(i - left +1, res)
                else:
                    res = max(res, i-stack[-1])        
        return res
```



描述如下：

1. 初始化一个空栈stack, 一个表示可能的合法子串的起始下标left，一个保存子串最大长度值的变量res

2. 遍历字符串的每一个字符：

   A. 如果是 左括号，那么压栈

   B. 如果是右括号，分两种情况讨论：

   (1) 如果是空栈，那么说明这个字符导致前面的合法字符串在这个位置停止，重置left 的值为下一个位置。

   (2) 如果不是空栈，那么弹出栈顶的左括号与之匹配，低效，并重新计算res的值，res每次遇到匹配的串都是值在逐步扩大的。res的值计算又分两种情况计算，具体情况见代码。

3. 输出遍历完成后的res的值。



### 勒文斯坦编辑距离

```python
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:        
        length1 = len(word1)
        length2 = len(word2)
        if length1 == 0: return length2 # 注意，必须考虑边界值，否则就会出问题
        if length2 == 0: return length1
        dp = [ [ 0 for i in range(length1) ] for j in range(length2) ]
        for i in range(0, length1):
            if word1[i] == word2[0]: dp[0][i] = i
            elif i==0: dp[0][i] = 1
            else: dp[0][i] = 1 + dp[0][i-1]
        for i in range(0, length2):
            if word2[i] == word1[0]: dp[i][0] = i
            elif i==0: dp[i][0] = 1
            else: dp[i][0] = 1 + dp[i-1][0]
        #
        for j in range(1, length2):
            for i in range(1, length1):
                if word1[i] == word2[j]: dp[j][i] = dp[j-1][i-1]
                else:
                    dp[j][i] = min(dp[j-1][i], dp[j][i-1], dp[j-1][i-1]) +1
        return dp[length2-1][length1-1]
```

### 最长公共序列 leet1143

```python
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        len1 = len(text1)
        len2 = len(text2)
        memo = {}
        def helper(i, j):
            if i < 0 or j < 0: return 0
            if memo.get((i, j)):
                return memo.get((i, j))
            v = 0
            if text1[i] == text2[j]: 
                v =  1+ helper(i-1, j-1)
            else:
                v = max(helper(i-1, j), helper(i, j-1))
            memo[(i, j)] = v
            return v
        return helper(len1-1, len2-1)
```



### 滑动窗口之异位词

```python
class Solution:
    def findAnagrams(self, s, p) :
        res = []
        left = 0
        cnt = 0
        cnt_map = {} # 是否包含所有字母
        s_map = {}
        for c in p:
            cnt_map[c] = cnt_map.get(c, 0) + 1
        for i in range(len(s)):
            s_map[s[i]] = s_map.get(s[i], 0) + 1
            if s_map[s[i]] == cnt_map.get(s[i], 0):
                cnt += 1
            while cnt == len(cnt_map):
                # 如果刚好合适，那么放入结果集
                if i - left + 1 == len(p): res.append(left)
                # 如果最左边的字母是必须的字母，如果出现的数量>1, cnt 不变，否则-1
                # 如果不是，那么就继续前进
                if cnt_map.get(s[left], 0) > 0:
                    s_map[s[left]] -= 1
                    if s_map.get(s[left]) < cnt_map.get(s[left]):
                        cnt -= 1
                left += 1
        return res
```



### 滑动窗口之无重复的最长子串

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        left = right = 0
        window = {}
        res = 0
        # 从左向右滑动窗口
        while right < len(s):
            # widnow记录每一个字符串出现的位置
            if (window.get(s[right]) is None):
                window[s[right]] = right
                # 比较当前窗口大小和res值，以更大的值更新res
                res = max(res, right - left + 1)
                right += 1
            else:
                # 如果有重复的值，则修改left为当前字符最后一次出现的位置
                #   并且删掉left之前的键
                p = window.get(s[right])
                while left <= p:
                    del window[s[left]]
                    left += 1
        return res

```







