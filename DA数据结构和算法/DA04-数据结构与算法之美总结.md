# 最感兴趣的



# 简单的数据结构

## 链表 Lec6、7

## 队列  lec9

## 栈 lec8

## 哈希算法与散列表 lec18-22

## 基本二叉树 lec 23-24 



# 排序专题 lec11-14

## 桶排序

## 基数排序

## 堆排序 lec28,29



### 线性排序的解释
T(n) = O(n)

## 特点
- 对数据本身要求高, 比如分布集中  

## 桶排序
- 桶排序的特点是: 知道排序的元素的分布规律为: 分布域集中, 而且呈现分段式的特点, 段之间相对均匀.  
- 在了解分布的基础上, 先定义好很多排好序的桶,或者分段, 然后把相应的数据丢到桶内, 再对桶内进行某种方式的排序.   







# 查找专题 

多数是基于排序基础上，少数基于特定数据结构上的



## 二分查找 lec15-16

## 跳表 lec17

## 散列表 lec18-20

## 哈希算法 lec21,22



# 交叉话题

## 树与递归 lec27



# 复杂数据结构

## 红黑树 lec25,26

- 红和黑，真的染颜色了吗？
- 为什么这玩意这么奇怪？

## 图 lec30, 31

lec31 好友搜索

## B+树和数据库索引的实现？lec48

？ 什么是数据库的索引？



# 字符串算法专题 lec32,33,

？ 什么是KMP算法？

？KL算法?

字符串编辑距离 lec42 



## 哈希算法思路 lec32

## BM算法，KMP算法 lec34

## trie 树 lec35

## ac自动机 lec36



# 经典算法模式

## 贪心算法 lec37

## 分治算法 lec38

## 动态规划 lec40-42

？硬币找零问题



## 回溯算法 lec39

39讲

又叫试错算法、枚举算法、深度遍历算法

我们在第 31 节提到，深度优先搜索算法利用的是回溯算法思想。这个算法思想非常简单，但是应用却非常广泛。它除了用来指导像深度优先搜索这种经典的算法设计之外，还可以用在很多实际的软件开发场景中，比如正则表达式匹配、编译原理中的语法分析等。

除此之外，很多经典的数学问题都可以用回溯算法解决，比如数独、八皇后、0-1 背包、图的着色、旅行商问题、全排列等等。

回溯算法的思想非常简单，大部分情况下，都是用来解决**广义的搜索问题**，也就是，从一组可能的解中，选择出一个满足要求的解。回溯算法非常适合用递归来实现，在实现的过程中，剪枝操作是提高回溯效率的一种技巧。利用剪枝，我们并不需要穷举搜索所有的情况，从而提高搜索效率。



# 高级复杂问题

## 拓扑排序-源代码的以来分析-图的应用lec43



## 最短距离 lec44

？ 如何算法最短出行路径？



## 位图？lec45



## 推荐系统 向量空间 lec47



## A* 寻路算法？lec49

## 索引与海量数据检索 lec50

## 并行算法  lec51



# 实战环境的数据结构

## redis 实际数据结构 lec52

## 搜索引擎背后的数据结构 #53

## 短网址系统的数据结构和算法？lec56 



```
- 介绍  
算法的分类:  
冒泡, 插入, 选择; 归并, 快排; 桶排序, 计数排序, 基数排序;  

- 如何分析一个排序算法?  
  - 时间复杂度(执行效率)  
  最坏, 最好, 平均  
  时间复杂度的系数, 常数, 低阶  
  比较次数和交换次数  
  - 算法的空间复杂度(内存消耗)  
  - 算法的稳定性  
  如果有多个排序字段, 如果采用稳定算法排序, 可以先按低优先级字段排序, 再按高优先级字段排序  
  基数排序的原理是这个.  
- 冒泡排序  
通过检查每轮排序有无交换, 可以检测是否实现排序, 所以, 冒泡排序可以有优化.  
选择排序也有交换, 但是选择排序采用局部有序, 逐步扩大有序部分的策略, 无法在第N轮检测是否所有元素有无交换, 不能像冒泡那样有优化的可能性.   
   - 逆序数和顺序数的关系?  
   逆序数确实等于移动的次数. 这个不言而喻.  
   因为排序的目的就是消除逆序, 让逆序数为 0.  

- 选择排序  
选择排序是记录最小元素位置, 然后隔空交换, 所以会破坏稳定性.  
就比较次数而言, 选择排序会每次都把未排序区全部扫描一遍, 是最暴力的解法, 它采取的思路是消灭未排序区, 没有利用已经排序的区域(相反于插入排序), 而冒泡排序虽然和选择排序较为相似, 但是冒泡排序就近交换位置的做法, 可以统计本轮排序是否交换元素来判断是否完成排序. 采用了一种记忆的方式.  
选择排序选择遗忘, 每次从头开始, 没有优化的可能. 

- 这三类排序的特点  
冒泡和选择每轮都能确定一个未排序边缘的最大值, 逐步缩小未排序区.  
插入排序每轮都能扩大已排序区的值.  
冒泡排序和选择排序的移动次数是相同的, 都是逆序数次.  
而选择排序的移动次数, 比如 6, 5, 4, 3, 2, 1, 它的移动次数是3 次.  

- 插入排序比冒泡排序优的原因在哪?  
移动次数都相同.  
但是, 插入排序移动的时候, 单纯向后移位, 一步操作, 而交换一对元素, 则需要3步操作, 性能自然下降. 在移动次数相同的情况下, 优劣不言而喻.  

- 数据结构的适配性  
选择排序记住下标, 只能在数组下操作, 如果非要在链表下操作, 那么空间复杂度将再上一个档次, 变成 O(n^3)   
但是转念一想, 其实记住引用, 也是可以的.  
冒泡排序和插入排序, 放在链表里执行, 还是要变相的采用下标法则, 采用计数.  
  
    
 # 40:动态规划凑单问题:
- 介绍  
双 11 满减开始, 凑够 200 优惠, 那么那些商品能凑够 200 又价钱最少.
- 0,1 背包问题  
有一组物品, 重量确定, 有一个背包, 承重确定, 如果把这组物品里面选择一些放进去背包, 最大能装多少?  
   - 第一种解法: 递归. 每次决定一个东西装或者不装. 直到结束.  
   递归树的解法是, 每次递归都有一个当前状态, 这个状态有两个属性, 一个是判断第几个节点, 一个是当前已装重量.  
   可以采用备忘录模式, 遇到相同的结点, 直接跳过.  
   而这个备忘录的形式, 是采用数组.  
   代码实现: TODO

   - 第二种解法就是动态规划, 动态规划是在备忘录思想上的进一步发展, 采用更加激进的思路, 把所有的状态都保存到数组里面去.  
   采用数组的状态结点之间的运算, 看能不能通过上一层节点状态推算出下一层的某个节点状态.  
   数组之间会有大量的空白的元素表示不可能达到的结点. 但是必须空着.  
   二维元素之间的运算只能通过数组表示.  
   代码实现: TODO
   时间复杂度是 O(n*w)  
   为什么不是 O(n), 而是 n(n*w), 是因为每一层要复制 w 个元素到下一层, 所以必须是 n*w.  
   而我们回顾递归树的时间复杂度, 是O(2^^n)  

   - 降低动态规划的空间复杂度: TODO
- 0, 1问题的升级: 这组物品再加上一个属性, 价值, 这次我们不再考量重量最大, 而是追求价值最大.  
代码实现: TDOO

- 如何迭代的算出在最终状态后,前面的选择呢? 这也是可以的. 代码实现: TODO
```







