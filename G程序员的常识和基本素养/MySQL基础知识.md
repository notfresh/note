# 开篇

面试需要，你懂的。

# 第一讲





## MySQL的架构

分层架构，从上到下依次是：连接器，分析器，优化器，执行器，存储引擎。



### 分析器

词法分析

calcite sql语法解析开源



### 优化器

职责是对sql调优



### SQL的优化

1. 不要使用select *
2. 不要对索引运算



## MyISAM 存储引擎

表级别，不是库级别

索引，事务，

> 安装目录下的data目录可能存放着表格数据
>
> .ibd 是 innodb 引擎，.myd是MyISam 引擎。



## 事务的分类

带保存点的扁平事务

链式事务

嵌套事务



### 事务的实现原理-原子性的实现原理

undo log 逻辑日志，针对数据库的增删改，创建一条反向SQL，并且可以开启多版本控制

写入时机：先写入log buffer，再写入 os buffer。





### 事务的实现原理-持久性的实现原理

redo log，物理日志，记录整个页的数据变化，

写入时机：先写入log buffer，再写入 os buffer。同 undo log



### 日志写入时机的选择

一个参数`innodb_flush_log_at_trx_commit`，这个参数主要控制InnoDB将`log buffer`中的数据写入`OS buffer`，并刷到磁盘的时间点，取值分别为0，1，2，默认是1。

首先查看MySQL默认设置的方式1，也就是每次提交后直接写入`OS buffer`，并且调用系统函数`fsync()`把日志写到磁盘上。而方式2是直接写入`OS buffer`，再写入磁盘，少了一次数据拷贝的过程（从`log buffer`到`OS buffer`），所以方式2比方式0更加高效。





# 第3讲 事务的特性 



读未提交，读提交，重复度，串行化读

脏读，幻读，不可重复度

脏读：两个事务互相影响，一个事务里的写操作还未提交就被另一个事务读到。

不可重复读：两个事务同时开启，一个事务修改数据并完成了提交，被另一个事务读到，导致这个事务在两次读的过程中看到的数据不一样

幻读：在可重复读的基础上，两个事务写入相同主键的记录，后提交的一个事务失败，



没有索引，执行 select for update 就会加表锁，

死锁：事务T1锁住了一行 line1,  事务T2锁住了一行 line2,  在T1里面查询 line2， 在T2里面查询 line1，会引起死锁。





# 第4讲 MySql 的ACID原理



select * from table  where XXX for update， 默认加的是行锁，但是如果没有索引，加的就是表锁。



## 

两个事务发生的死锁，那么会选择 undo比较少的事务进行回滚。

## 死锁的检测

（1）超时等待（2）检测等待图有无环的存在。



## 幻读的解决

间隙锁（叫区间锁更合适），提前给某一段加上锁，让另外一个事务无法插入和删除数据。

nextkey



























