# 序

当我不知道我为什么要学习算法，要刷题目的时候，我很苦恼。如果是为了一份 offer 而刷题的话，我觉得这个应付的过程是非常痛苦的。 



# 树

树是线性表之后稍微复杂的结构。  

树的应用场景有：文件目录。  





# 时间复杂度





# 快排

狗皮膏药，贴到哪里都好。

时间复杂度为 nlogn, 空间复杂度为 logn。 


```
n*1 + (n/2)*2 + (n/4)*4 + ... + (1)*n  =  o(logn * n) = o(nlogn)
总共 logn 项
进行递归logn次，每次都是原地排序
```



### 对快速排序的优化

#### 重复元素

如果完成了对一个元素的定位，然后向左向右探测，发现有重复元素，则缩小下一次快排的范围。

#### 选点

如果数据原来就是有序的或者接近有序的，每次分区点都选择最后一个数据，那快速排序算法就会变得非常糟糕，时间复杂度就会退化为 O(n2)。实际上，这种 O(n2) 时间复杂度出现的主要原因还是因为我们分区点选的不够合理。

最理想的分区点是：被分区点分开的两个分区中，数据的数量差不多。
1. 三数取中法
2. 随机法



## 快排的变体排序

可以查找前K大数据。


# 归并排序

时间复杂度

```
举例：
1 * 8（不用排序）【1表示单词排序的元素的数量，8表示本轮排序次数】 + 2* (8/2) + 4*(8/2/2) + 8*(8/2/2/2) = log8*8
时间复杂度：nlogn
```

空间复杂度：本来是需要n的，但是原地排序：logn，因为每次都会释放掉一次内存

 拷贝排序：

```
8*1 + 4*2 + 8*1 = log8 * 8  
```

实际上，递归代码的空间复杂度并不能像时间复杂度那样累加。刚刚我们忘记了最重要的一点，那就是，尽管每次合并操作都需要申请额外的内存空间，但在合并完成之后，临时开辟的内存空间就被释放掉了。在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过 n 个数据的大小，所以空间复杂度是 O(n)。



# 桶排序

适宜外排序，可以解决大规模数据排序问题。



如果分布比较均匀而且范围有限，则可以把待排序数据划分到N个桶里面。

如果不均匀，可以根据计数算法，想办法把数据均匀的丢到N个桶里面。（自己动脑子想）

## 计数排序

如果分布的范围更小，那么就把每一个数据设置一个桶，桶排序就变成了计数排序。



# 基数排序

适合排序对象格式整齐划一。





# 通用排序

堆排序和快速排序都有比较多的应用，比如 Java 语言采用堆排序实现排序函数，C 语言使用快速排序实现排序函数。



<img src="https://static001.geekbang.org/resource/image/1f/fd/1f6ef7e0a5365d6e9d68f0ccc71755fd.jpg" alt="img" style="zoom:70%;" />

qsort() 会优先使用归并排序来排序输入数据

要排序的数据量比较大的时候，qsort() 会改为用快速排序算法来排序。

O(n2) 时间复杂度的算法并不一定比 O(nlogn) 的算法执行时间长。



时间复杂度代表的是一个增长趋势，如果画成增长曲线图，你会发现 O(n2) 比 O(nlogn) 要陡峭，也就是说增长趋势要更猛一些。但是，我们前面讲过，在大 O 复杂度表示法中，我们会省略低阶、系数和常数，也就是说，O(nlogn) 在没有省略低阶、系数、常数之前可能是 O(knlogn + c)，而且 k 和 c 有可能还是一个比较大的数。



用哨兵来简化代码。



